/**
 * DOCX Editor - ç½‘é¡µç‰ˆWordæ–‡æ¡£ç¼–è¾‘å™¨
 * 
 * æˆ˜ç•¥æ„ä¹‰ï¼š
 * 1. æ¶æ„ä»·å€¼ï¼šé€šè¿‡WebæŠ€æœ¯å®ç°è·¨å¹³å°æ–‡æ¡£ç¼–è¾‘ï¼Œé¿å…å¹³å°ä¾èµ–
 * 2. å¹³å°ä»·å€¼ï¼šä¸ºAIæä¾›å®Œæ•´çš„æ–‡æ¡£å¤„ç†èƒ½åŠ›ï¼Œæ”¯æŒå¯è§†åŒ–ç¼–è¾‘å’Œç²¾ç¡®å¯¼å‡º
 * 3. ç”Ÿæ€ä»·å€¼ï¼šä½œä¸ºæ–‡æ¡£å¤„ç†åŸºç¡€è®¾æ–½ï¼Œæ”¯æŒå…¶ä»–å·¥å…·é›†æˆæ–‡æ¡£åŠŸèƒ½
 * 
 * è®¾è®¡ç†å¿µï¼š
 * é‡‡ç”¨å‰åç«¯åˆ†ç¦»æ¶æ„ï¼Œå‰ç«¯æä¾›å¯Œæ–‡æœ¬ç¼–è¾‘å™¨å®ç°æ‰€è§å³æ‰€å¾—ï¼Œ
 * åç«¯è´Ÿè´£docxæ ¼å¼è½¬æ¢ï¼Œç¡®ä¿å¯¼å‡ºæ–‡æ¡£ä¸ç¼–è¾‘å†…å®¹å®Œå…¨ä¸€è‡´ã€‚
 * 
 * ä¸ºä»€ä¹ˆé‡è¦ï¼š
 * è§£å†³äº†AIåœ¨æ–‡æ¡£å¤„ç†ä¸­çš„å¯è§†åŒ–ç¼–è¾‘éœ€æ±‚ï¼Œè®©AIèƒ½å¤Ÿç†è§£å’Œæ“ä½œ
 * å¤æ‚æ–‡æ¡£æ ¼å¼ï¼Œè€Œä¸ä»…ä»…æ˜¯çº¯æ–‡æœ¬å¤„ç†ã€‚
 */

module.exports = {
  getDependencies() {
    return {
      'express': '^4.18.2',
      'docx': '^8.5.0',
      'mammoth': '^1.6.0',
      'multer': '^1.4.5-lts.1',
      'cors': '^2.8.5',
      'uuid': '^9.0.1'
    };
  },

  getMetadata() {
    return {
      id: 'docx-editor',
      name: 'DOCX Editor',
      description: 'ç½‘é¡µç‰ˆWordæ–‡æ¡£ç¼–è¾‘å™¨ï¼Œæ”¯æŒå¯è§†åŒ–ç¼–è¾‘å’Œç²¾ç¡®docxå¯¼å‡º',
      version: '1.0.0',
      author: 'é²ç­'
    };
  },

  getSchema() {
    return {
      parameters: {
        type: 'object',
        properties: {
          action: {
            type: 'string',
            enum: ['start', 'stop', 'status'],
            description: 'æ“ä½œç±»å‹ï¼šstart-å¯åŠ¨ç¼–è¾‘å™¨ï¼Œstop-åœæ­¢æœåŠ¡ï¼Œstatus-æŸ¥çœ‹çŠ¶æ€',
            default: 'start'
          },
          port: {
            type: 'number',
            description: 'æœåŠ¡ç«¯å£å·',
            minimum: 3000,
            maximum: 65535,
            default: 3000
          }
        },
        required: ['action']
      }
    };
  },

  async execute(params) {
    const { api } = this;
    const { action = 'start', port = 3000 } = params;

    api.logger.info('DOCXç¼–è¾‘å™¨æ“ä½œ', { action, port });

    try {
      switch (action) {
        case 'start':
          return await this.startEditor(port);
        case 'stop':
          return await this.stopEditor();
        case 'status':
          return await this.getStatus();
        default:
          throw new Error(`æœªçŸ¥æ“ä½œ: ${action}`);
      }
    } catch (error) {
      api.logger.error('æ“ä½œå¤±è´¥', error);
      return {
        success: false,
        error: error.message,
        suggestion: 'è¯·æ£€æŸ¥ç«¯å£æ˜¯å¦è¢«å ç”¨æˆ–é‡æ–°å¯åŠ¨æœåŠ¡'
      };
    }
  },

  async startEditor(port) {
    const { api } = this;
    
    // æ£€æŸ¥æœåŠ¡æ˜¯å¦å·²è¿è¡Œ
    const status = await api.storage.getItem('server_status');
    if (status && status.running) {
      return {
        success: true,
        message: 'ç¼–è¾‘å™¨å·²åœ¨è¿è¡Œ',
        url: `http://localhost:${status.port}`,
        status: 'already_running'
      };
    }

    // åŠ è½½ä¾èµ–
    const express = await api.importx('express');
    const cors = await api.importx('cors');
    const multer = await api.importx('multer');
    const path = require('path');
    const fs = require('fs');

    // åˆ›å»ºExpressåº”ç”¨
    const app = express();
    app.use(cors());
    app.use(express.json({ limit: '50mb' }));
    app.use(express.urlencoded({ extended: true, limit: '50mb' }));

    // é…ç½®æ–‡ä»¶ä¸Šä¼ 
    const upload = multer({
      dest: '/tmp/',
      limits: { fileSize: 10 * 1024 * 1024 } // 10MB
    });

    // é™æ€æ–‡ä»¶æœåŠ¡
    app.get('/', (req, res) => {
      res.send(this.getEditorHTML());
    });

    app.get('/editor.js', (req, res) => {
      res.setHeader('Content-Type', 'application/javascript');
      res.send(this.getEditorJS());
    });

    // APIè·¯ç”±
    app.post('/api/upload', upload.single('docx'), async (req, res) => {
      try {
        const result = await this.handleFileUpload(req.file);
        res.json(result);
      } catch (error) {
        res.status(500).json({ error: error.message });
      }
    });

    app.post('/api/export', async (req, res) => {
      try {
        const result = await this.handleExport(req.body);
        res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document');
        res.setHeader('Content-Disposition', 'attachment; filename="document.docx"');
        res.send(result);
      } catch (error) {
        res.status(500).json({ error: error.message });
      }
    });

    // å¯åŠ¨æœåŠ¡å™¨
    const server = app.listen(port, () => {
      api.logger.info(`DOCXç¼–è¾‘å™¨å·²å¯åŠ¨`, { port });
    });

    // ä¿å­˜æœåŠ¡çŠ¶æ€
    await api.storage.setItem('server_status', {
      running: true,
      port: port,
      startTime: Date.now()
    });

    // ä¿å­˜æœåŠ¡å™¨å¼•ç”¨
    this.server = server;

    return {
      success: true,
      message: 'DOCXç¼–è¾‘å™¨å¯åŠ¨æˆåŠŸ',
      url: `http://localhost:${port}`,
      instructions: [
        '1. åœ¨æµè§ˆå™¨ä¸­æ‰“å¼€ä¸Šè¿°URL',
        '2. å¼€å§‹ç¼–è¾‘æ–‡æ¡£æˆ–ä¸Šä¼ ç°æœ‰docxæ–‡ä»¶',
        '3. ç¼–è¾‘å®Œæˆåç‚¹å‡»å¯¼å‡ºæŒ‰é’®ä¸‹è½½docxæ–‡æ¡£',
        '4. æ–‡æ¡£ä¼šè‡ªåŠ¨ä¿å­˜åˆ°æµè§ˆå™¨æœ¬åœ°å­˜å‚¨'
      ]
    };
  },

  async stopEditor() {
    const { api } = this;
    
    const status = await api.storage.getItem('server_status');
    if (!status || !status.running) {
      return {
        success: true,
        message: 'ç¼–è¾‘å™¨æœªåœ¨è¿è¡Œ',
        status: 'not_running'
      };
    }

    if (this.server) {
      this.server.close();
      this.server = null;
    }

    await api.storage.setItem('server_status', {
      running: false,
      stopTime: Date.now()
    });

    return {
      success: true,
      message: 'ç¼–è¾‘å™¨å·²åœæ­¢'
    };
  },

  async getStatus() {
    const { api } = this;
    const status = await api.storage.getItem('server_status');
    
    if (!status) {
      return {
        success: true,
        status: 'never_started',
        message: 'ç¼–è¾‘å™¨ä»æœªå¯åŠ¨è¿‡'
      };
    }

    return {
      success: true,
      status: status.running ? 'running' : 'stopped',
      port: status.port,
      url: status.running ? `http://localhost:${status.port}` : null,
      startTime: status.startTime,
      stopTime: status.stopTime
    };
  },

  async handleFileUpload(file) {
    const { api } = this;
    
    if (!file) {
      throw new Error('æœªä¸Šä¼ æ–‡ä»¶');
    }

    const mammoth = await api.importx('mammoth');
    const fs = require('fs');

    // è¯»å–docxæ–‡ä»¶å¹¶è½¬æ¢ä¸ºHTML
    const result = await mammoth.convertToHtml({ path: file.path });
    
    // æ¸…ç†ä¸´æ—¶æ–‡ä»¶
    fs.unlinkSync(file.path);

    return {
      success: true,
      html: result.value,
      messages: result.messages
    };
  },

  async handleExport(data) {
    const { api } = this;
    const { Document, Paragraph, TextRun, Packer } = await api.importx('docx');
    
    // åˆ›å»ºæ–°æ–‡æ¡£
    const doc = new Document({
      sections: [{
        properties: {},
        children: await this.convertHtmlToDocx(data.html)
      }]
    });

    // ç”Ÿæˆdocxæ–‡ä»¶
    return await Packer.toBuffer(doc);
  },

  async convertHtmlToDocx(html) {
    // ç®€åŒ–çš„HTMLåˆ°docxè½¬æ¢
    // è¿™é‡Œéœ€è¦æ›´å¤æ‚çš„è§£æé€»è¾‘æ¥å¤„ç†å„ç§HTMLæ ‡ç­¾
    const { Paragraph, TextRun } = await this.api.importx('docx');
    
    // ç§»é™¤HTMLæ ‡ç­¾ï¼Œæå–çº¯æ–‡æœ¬
    const text = html.replace(/<[^>]*>/g, '').trim();
    
    // æŒ‰æ®µè½åˆ†å‰²
    const paragraphs = text.split('\n').filter(p => p.trim());
    
    return paragraphs.map(paragraph => 
      new Paragraph({
        children: [new TextRun(paragraph)]
      })
    );
  },

  getEditorHTML() {
    return `<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DOCX Editor - ç½‘é¡µç‰ˆWordç¼–è¾‘å™¨</title>
    <script src="https://cdn.quilljs.com/1.3.6/quill.min.js"></script>
    <link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
        }
        .header {
            background: #2c3e50;
            color: white;
            padding: 15px 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .header h1 {
            margin: 0;
            font-size: 24px;
        }
        .toolbar {
            background: white;
            padding: 10px 20px;
            border-bottom: 1px solid #ddd;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }
        .btn-primary {
            background: #3498db;
            color: white;
        }
        .btn-primary:hover {
            background: #2980b9;
        }
        .btn-success {
            background: #27ae60;
            color: white;
        }
        .btn-success:hover {
            background: #229954;
        }
        .main-container {
            display: flex;
            height: calc(100vh - 140px);
        }
        .editor-container {
            flex: 1;
            background: white;
            margin: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        #editor {
            height: 100%;
            border: none;
        }
        .sidebar {
            width: 250px;
            background: white;
            margin: 20px 20px 20px 0;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            padding: 20px;
        }
        .status-bar {
            background: #34495e;
            color: white;
            padding: 8px 20px;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
        }
        input[type="file"] {
            display: none;
        }
        .file-label {
            display: inline-block;
            padding: 8px 16px;
            background: #3498db;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        .file-label:hover {
            background: #2980b9;
        }
        .stats {
            margin-top: 20px;
        }
        .stats h3 {
            margin: 0 0 10px 0;
            color: #2c3e50;
        }
        .stat-item {
            margin: 5px 0;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ğŸ“ DOCX Editor</h1>
    </div>
    
    <div class="toolbar">
        <label for="upload-input" class="file-label">
            ğŸ“‚ ä¸Šä¼ DOCX
        </label>
        <input type="file" id="upload-input" accept=".docx" />
        
        <button class="btn btn-success" onclick="exportDocument()">
            ğŸ’¾ å¯¼å‡ºDOCX
        </button>
        
        <button class="btn btn-primary" onclick="saveToLocal()">
            ğŸ’¿ æœ¬åœ°ä¿å­˜
        </button>
        
        <button class="btn btn-primary" onclick="loadFromLocal()">
            ğŸ“– æœ¬åœ°åŠ è½½
        </button>
    </div>
    
    <div class="main-container">
        <div class="editor-container">
            <div id="editor"></div>
        </div>
        
        <div class="sidebar">
            <h3>ğŸ“Š æ–‡æ¡£ç»Ÿè®¡</h3>
            <div class="stats">
                <div class="stat-item">å­—ç¬¦æ•°: <span id="char-count">0</span></div>
                <div class="stat-item">å•è¯æ•°: <span id="word-count">0</span></div>
                <div class="stat-item">æ®µè½æ•°: <span id="para-count">0</span></div>
            </div>
            
            <h3>ğŸ’¡ ä½¿ç”¨è¯´æ˜</h3>
            <ul style="font-size: 12px; color: #666;">
                <li>æ”¯æŒå¯Œæ–‡æœ¬ç¼–è¾‘</li>
                <li>è‡ªåŠ¨ä¿å­˜åˆ°æµè§ˆå™¨</li>
                <li>ä¸Šä¼ docxæ–‡ä»¶ç¼–è¾‘</li>
                <li>ä¸€é”®å¯¼å‡ºæ ‡å‡†docx</li>
            </ul>
        </div>
    </div>
    
    <div class="status-bar">
        <span>å°±ç»ª</span>
        <span id="last-saved">æœªä¿å­˜</span>
    </div>
    
    <script src="/editor.js"></script>
</body>
</html>`;
  },

  getEditorJS() {
    return `// DOCX Editor JavaScript
let quill;
let autoSaveTimer;

// åˆå§‹åŒ–ç¼–è¾‘å™¨
document.addEventListener('DOMContentLoaded', function() {
    // åˆå§‹åŒ–Quillç¼–è¾‘å™¨
    quill = new Quill('#editor', {
        theme: 'snow',
        modules: {
            toolbar: [
                [{ 'header': [1, 2, 3, 4, 5, 6, false] }],
                ['bold', 'italic', 'underline', 'strike'],
                [{ 'color': [] }, { 'background': [] }],
                [{ 'font': [] }],
                [{ 'align': [] }],
                [{ 'list': 'ordered'}, { 'list': 'bullet' }],
                [{ 'indent': '-1'}, { 'indent': '+1' }],
                ['link', 'image'],
                ['clean']
            ]
        }
    });
    
    // ç›‘å¬å†…å®¹å˜åŒ–
    quill.on('text-change', function() {
        updateStats();
        scheduleAutoSave();
    });
    
    // æ–‡ä»¶ä¸Šä¼ å¤„ç†
    document.getElementById('upload-input').addEventListener('change', handleFileUpload);
    
    // ä»æœ¬åœ°å­˜å‚¨åŠ è½½å†…å®¹
    loadFromLocal();
    
    // åˆå§‹ç»Ÿè®¡
    updateStats();
});

// å¤„ç†æ–‡ä»¶ä¸Šä¼ 
async function handleFileUpload(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    if (!file.name.endsWith('.docx')) {
        alert('è¯·é€‰æ‹©.docxæ ¼å¼çš„æ–‡ä»¶');
        return;
    }
    
    const formData = new FormData();
    formData.append('docx', file);
    
    try {
        updateStatus('æ­£åœ¨ä¸Šä¼ å’Œè§£ææ–‡ä»¶...');
        
        const response = await fetch('/api/upload', {
            method: 'POST',
            body: formData
        });
        
        if (!response.ok) {
            throw new Error('ä¸Šä¼ å¤±è´¥');
        }
        
        const result = await response.json();
        
        if (result.success) {
            quill.root.innerHTML = result.html;
            updateStats();
            updateStatus('æ–‡ä»¶ä¸Šä¼ æˆåŠŸ');
        } else {
            throw new Error(result.error);
        }
        
    } catch (error) {
        alert('æ–‡ä»¶ä¸Šä¼ å¤±è´¥: ' + error.message);
        updateStatus('ä¸Šä¼ å¤±è´¥');
    }
    
    // æ¸…ç©ºæ–‡ä»¶è¾“å…¥
    event.target.value = '';
}

// å¯¼å‡ºæ–‡æ¡£
async function exportDocument() {
    try {
        updateStatus('æ­£åœ¨ç”ŸæˆDOCXæ–‡ä»¶...');
        
        const html = quill.root.innerHTML;
        
        const response = await fetch('/api/export', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ html: html })
        });
        
        if (!response.ok) {
            throw new Error('å¯¼å‡ºå¤±è´¥');
        }
        
        // ä¸‹è½½æ–‡ä»¶
        const blob = await response.blob();
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'document_' + new Date().toISOString().slice(0, 10) + '.docx';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        window.URL.revokeObjectURL(url);
        
        updateStatus('å¯¼å‡ºæˆåŠŸ');
        
    } catch (error) {
        alert('å¯¼å‡ºå¤±è´¥: ' + error.message);
        updateStatus('å¯¼å‡ºå¤±è´¥');
    }
}

// ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
function saveToLocal() {
    const content = quill.getContents();
    localStorage.setItem('docx-editor-content', JSON.stringify(content));
    updateStatus('å·²ä¿å­˜åˆ°æœ¬åœ°');
    updateLastSaved();
}

// ä»æœ¬åœ°å­˜å‚¨åŠ è½½
function loadFromLocal() {
    const saved = localStorage.getItem('docx-editor-content');
    if (saved) {
        try {
            const content = JSON.parse(saved);
            quill.setContents(content);
            updateStatus('å·²ä»æœ¬åœ°åŠ è½½');
        } catch (error) {
            console.error('åŠ è½½æœ¬åœ°å†…å®¹å¤±è´¥:', error);
        }
    }
}

// è‡ªåŠ¨ä¿å­˜
function scheduleAutoSave() {
    if (autoSaveTimer) {
        clearTimeout(autoSaveTimer);
    }
    
    autoSaveTimer = setTimeout(() => {
        saveToLocal();
    }, 2000); // 2ç§’åè‡ªåŠ¨ä¿å­˜
}

// æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
function updateStats() {
    const text = quill.getText();
    const html = quill.root.innerHTML;
    
    // å­—ç¬¦æ•°ï¼ˆä¸åŒ…æ‹¬ç©ºæ ¼ï¼‰
    const charCount = text.replace(/\s/g, '').length;
    
    // å•è¯æ•°
    const wordCount = text.trim().split(/\s+/).filter(word => word.length > 0).length;
    
    // æ®µè½æ•°
    const paraCount = html.split('</p>').length - 1 || 1;
    
    document.getElementById('char-count').textContent = charCount;
    document.getElementById('word-count').textContent = wordCount;
    document.getElementById('para-count').textContent = paraCount;
}

// æ›´æ–°çŠ¶æ€æ 
function updateStatus(message) {
    document.querySelector('.status-bar span:first-child').textContent = message;
    setTimeout(() => {
        document.querySelector('.status-bar span:first-child').textContent = 'å°±ç»ª';
    }, 3000);
}

// æ›´æ–°æœ€åä¿å­˜æ—¶é—´
function updateLastSaved() {
    const now = new Date();
    const timeString = now.toLocaleTimeString();
    document.getElementById('last-saved').textContent = 'æœ€åä¿å­˜: ' + timeString;
}`;
  }
};